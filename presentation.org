
* Thinking Programs

** A Lisp Adventure


* Chapter I: A Remembrance

Let's remember Clojure: it barely has syntax

#+begin_src clojure :results output

;; values are values
5
nil
"Hi there"

;; vectors and maps (look ma, no commas!)
[1 2 3 4]
{:hello "maps" :with "keys" :and "values"}

;; and of course lists
'(4 3 2 1)

;; immutable data structures: operations return new ones
;; implemented as persistent, shared data structures
(def m {:name "Luis" :hobbies []})
(assoc m :hobbies ["Sports" "Socializing"])
m
(dissoc m :name)
m


;; expressions evaluate to values
(+ 1 1)
(if true "truth" "lies")
(conj  [1 2 3 4] 5)
(conj '(4 3 2 1) 5)

;; functions are easy
(defn flip [a b] 
  (vector b a)) 

(flip :x :y)

;; anonymous functions can be neat:
(#(vector %2 %1) :x :y)

;; destructuring is cool (use a vector or map in an assignment scenario)
((fn flip2 [[a b & _]] (vector b a)) [:x :y :z])
((fn greet! [{name :name}] (str "Hello " name)) {:name "Luis" :age 666})

;; scoping is lexical
(let [x 2
      y 3]
 (Math/pow x y))

;; functional approach to sequence stuff:

(reduce + (filter odd? (range 1 10)))

;; laziness in sequences:

(take 5 (iterate inc 1))

;; macros aren't scary
(defmacro infix [a op b] 
  `(~op ~a ~b)) ;; ` = quasiquote; ~ = unquote
(macroexpand '(infix 2 - 1))
(infix 1 + 2)
(infix 1 + (infix 2 + 2))


#+end_src


* Chapter II: The Problem of Search

Consider the game of Sudoku: Given a 9x9 grid, fill in the blanks such that:

- Every row has only one ocurrence of 1-9
- Same with every column
- Same with every 3x3 square in the grid

Consider the ideal of functional programming

- Deal with immutable, lazy, structures
- The solution should be as complex as the problem, not more (declarative)
- I.e. the /what/ should be unencumbered by the /how/
- Have your cake and eat it too: declarativeness should be *performant*.

* A declarative solution

A bit terse, but close to how we'd describe the solution:

#+begin_src clojure :results output

(require '[sentient-brown-bag.sudoku :as h])

(h/pprint-board h/example-board)

(defn solve-sudoku
  ;; given a board
  [board] 
  ;; get the first position found, if any
  (if-let [[i & _] 
           ;; is there at least one empty cell?
           (and (some  '#{-} board)  
                ;; find all positions for empty cells
                (h/pos '#{-} board))] 
    ;; solve the board with the new placement (creating a new board!)
    ;; it will either go deeper, one solved cell each time, or terminate
    (flatten (map #(solve-sudoku (assoc board i %)) 
                  ;; get all possible numbers for this position
                  (h/possible-placements board i))) 
    ;; no empty positions were found, return the board untouched
    board)) 

;; pipe the sample board into the solver, and print the result
(time (-> h/example-board solve-sudoku h/pprint-board))

#+end_src

Time permitting, we can explore the [[file:src/sentient_brown_bag/sudoku.clj][ancillary functions]] necessary.


* Some notes on the small details:

#+begin_src clojure :results output
(comment 
  (some #{1 2 3} [3 4 5 6])
  (some '#{-} '[1 - - 2])
  (some '#{-} '[1 2 3 4])
  (and [1 2 3] [1 2])
  (and nil (repeat 1))
  (assoc '[:a :b - :d] 2 :c)
  (if-let [[i & _] [4 3 2]] i :empty)
  (if-let [[i & _] nil] i :empty))


#+end_src


* The sad truth

- The declarative version, although very unencumbered by minutia... could be slow
- It recursively explores a potentially infinite space!
- Worst case, it's suboptimal in space and time complexity!
- Maybe we should just give up and do it in C?

* Chapter III: The Gift of Knowledge

- Define variables and /terms/
- Lil bit of code to do inference
- Lil bit of code to deal with seqs


* Chapter IV: The Reasoned Clojurian

- Quick core.logic primer
- Finite domains

* Chapter V: A Sentient Brown Bag

- Present core.logic solution

* Epilogue: Further Reading

- [[https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4][SICP, Chapter 4, Section 4: Logic Programming]]
- [[https://www.oreilly.com/library/view/the-joy-of/9781617291418/kindle_split_034.html][The Joy of Clojure: Chapter 16: "Thinking Programs"]]
- [[https://github.com/joyofclojure/book-source/tree/master/src/clj/joy/logic][The Joy of Clojure source code for Chapter 16's code samples]]
- [[https://mitpress.mit.edu/books/reasoned-schemer-second-edition][The Reasoned Schemer ($)]]
- [[http://minikanren.org/][Implementations of miniKanren in a bunch of languages]]
- [[https://github.com/clojure/core.logic/wiki/A-Core.logic-Primer][The core.logic wiki: a primer]]
- [[https://github.com/clojure/core.logic/wiki/A-Core.logic-Primer][The core.logic wiki: feature tour]]
